"""
Telegram –±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.
–ü–æ–∑–≤–æ–ª—è–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –∑–∞–¥–∞—á–∏, –¥–æ–±–∞–≤–ª—è—Ç—å –∫ –Ω–∏–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ —É–ø—Ä–∞–≤–ª—è—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏.
–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É–µ—Ç —Å Django –∏ FastAPI —Å–µ—Ä–≤–∏—Å–∞–º–∏.
"""

import asyncio
import json
import logging
import os
import sys
from datetime import datetime, timezone

import aiohttp
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stdout
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
logger.info("Starting bot initialization...")
logger.info(f"Environment variables: {dict(os.environ)}")

TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN")
logger.info(f"Raw TELEGRAM_TOKEN from env: {TELEGRAM_TOKEN}")

if not TELEGRAM_TOKEN:
    logger.error("TELEGRAM_TOKEN environment variable is not set!")
    raise ValueError("TELEGRAM_TOKEN environment variable is not set!")

try:
    logger.info(f"Bot token prefix: {TELEGRAM_TOKEN.split(':')[0]}")
    logger.info(f"Bot token length: {len(TELEGRAM_TOKEN)}")
except Exception as e:
    logger.error(f"Error parsing token: {e}")

DJANGO_SERVICE_URL = os.environ.get("DJANGO_SERVICE_URL", "http://django:8000")
FASTAPI_SERVICE_URL = os.environ.get("FASTAPI_SERVICE_URL", "http://fastapi:8001")

logger.info(f"Django service URL: {DJANGO_SERVICE_URL}")
logger.info(f"FastAPI service URL: {FASTAPI_SERVICE_URL}")

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
category_keyboard = types.InlineKeyboardMarkup(
    inline_keyboard=[
        [
            types.InlineKeyboardButton(text="üìù –°–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="create_category"),
            types.InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é", callback_data="delete_category")
        ],
        [
            types.InlineKeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π", callback_data="list_categories"),
            types.InlineKeyboardButton(text="üîç –ó–∞–¥–∞—á–∏ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏", callback_data="tasks_by_category")
        ],
        [
            types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∑–∞–¥–∞—á–∞–º", callback_data="back_to_tasks")
        ]
    ]
)

try:
    logger.info("Creating bot instance...")
    bot = Bot(token=TELEGRAM_TOKEN)
    logger.info("Bot instance created successfully")
    dp = Dispatcher()
    logger.info("Dispatcher created successfully")

    # –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ –º–µ–Ω—é –±–æ—Ç–∞
    main_menu_commands = [
        types.BotCommand(command="start", description="üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞"),
        types.BotCommand(command="tasks", description="üìã –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á"),
        types.BotCommand(command="add", description="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É"),
        types.BotCommand(command="categories", description="üìÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏"),
        types.BotCommand(command="search", description="üîç –ü–æ–∏—Å–∫ –ø–æ –∑–∞–¥–∞—á–∞–º"),
        types.BotCommand(command="stats", description="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"),
        types.BotCommand(command="deadlines", description="üîî –î–µ–¥–ª–∞–π–Ω—ã"),
        types.BotCommand(command="archive", description="üì¶ –ê—Ä—Ö–∏–≤ –∑–∞–¥–∞—á"),
        types.BotCommand(command="help", description="‚ùì –ü–æ–º–æ—â—å")
    ]

except Exception as e:
    logger.error(f"Error creating bot: {e}")
    raise

class TaskStates(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–æ–º —Å–æ–∑–¥–∞–Ω–∏—è –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–¥–∞—á."""
    selecting_action = State()
    adding_task = State()
    adding_task_description = State()
    selecting_category = State()
    adding_comment = State()
    setting_due_date = State()
    searching = State()

class CategoryStates(StatesGroup):
    """–°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–æ–º —Ä–∞–±–æ—Ç—ã —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏."""
    selecting_action = State()
    adding_category = State()
    deleting_category = State()
    viewing_tasks = State()

async def get_tasks(user_id: int):
    async with aiohttp.ClientSession() as session:
        headers = {"X-Bot-Access": "true"}
        async with session.get(
            f"{DJANGO_SERVICE_URL}/api/tasks/",
            headers=headers
        ) as response:
            return await response.json()

async def get_categories():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π."""
    async with aiohttp.ClientSession() as session:
        async with session.get(
            f"{DJANGO_SERVICE_URL}/api/categories/",
            headers={"X-Bot-Access": "true"}
        ) as response:
            if response.status == 200:
                return await response.json()
            logger.error(f"Error getting categories: {response.status}")
            return []

async def create_category(name: str):
    """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    try:
        logger.info(f"Creating category with name: {name}")
        async with aiohttp.ClientSession() as session:
            headers = {
                "X-Bot-Access": "true",
                "Content-Type": "application/json"
            }
            data = {"name": name}
            url = f"{DJANGO_SERVICE_URL}/api/categories/"
            logger.info(f"Making request to: {url}")
            logger.info(f"Headers: {headers}")
            logger.info(f"Data: {data}")
            
            async with session.post(
                url,
                json=data,
                headers=headers
            ) as response:
                response_text = await response.text()
                logger.info(f"Response status: {response.status}")
                logger.info(f"Response headers: {response.headers}")
                logger.info(f"Response text: {response_text}")
                
                if response.status != 201:
                    logger.error(f"Error creating category. Status: {response.status}")
                    logger.error(f"Response text: {response_text}")
                    return None
                
                try:
                    return json.loads(response_text)
                except json.JSONDecodeError as e:
                    logger.error(f"Error parsing response JSON: {e}")
                    logger.error(f"Raw response text: {response_text}")
                    return None
    except Exception as e:
        logger.error(f"Error in create_category: {str(e)}")
        logger.exception("Full traceback:")
        return None

async def delete_category(category_id: int):
    """–£–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    async with aiohttp.ClientSession() as session:
        async with session.delete(
            f"{DJANGO_SERVICE_URL}/api/categories/{category_id}/",
            headers={"X-Bot-Access": "true"}
        ) as response:
            return response.status == 204

async def get_tasks_by_category(category_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞—á –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    async with aiohttp.ClientSession() as session:
        async with session.get(
            f"{DJANGO_SERVICE_URL}/api/tasks/",
            headers={"X-Bot-Access": "true"}
        ) as response:
            if response.status == 200:
                tasks = await response.json()
                return [task for task in tasks if category_id in [cat['id'] for cat in task['categories']]]
            logger.error(f"Error getting tasks: {response.status}")
            return []

async def create_task(user_id: int, title: str, description: str, category_ids: list, due_date: str = None):
    try:
        logger.info(f"Creating task with data: user_id={user_id}, title={title}, description={description}, category_ids={category_ids}, due_date={due_date}")
        async with aiohttp.ClientSession() as session:
            headers = {
                "X-Bot-Access": "true",
                "Content-Type": "application/json"
            }
            data = {
                "title": title,
                "description": description or "",  # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ description –Ω–µ –±—É–¥–µ—Ç None
                "category_ids": category_ids or [],  # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ category_ids –Ω–µ –±—É–¥–µ—Ç None
                "completed": False,  # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                "due_date": due_date
            }
            logger.info(f"Sending request to {DJANGO_SERVICE_URL}/api/tasks/ with data: {data}")
            async with session.post(
                f"{DJANGO_SERVICE_URL}/api/tasks/",
                json=data,
                headers=headers
            ) as response:
                logger.info(f"Received response with status: {response.status}")
                response_text = await response.text()
                logger.info(f"Response text: {response_text}")
                
                if response.status != 201 and response.status != 200:
                    logger.error(f"Error creating task. Status: {response.status}, Response: {response_text}")
                    raise ValueError(f"Failed to create task: {response_text}")
                
                try:
                    response_data = json.loads(response_text)
                    logger.info(f"Task created successfully: {response_data}")
                    return response_data
                except json.JSONDecodeError as json_error:
                    logger.error(f"Error parsing response JSON: {json_error}")
                    raise ValueError(f"Invalid response format: {response_text}")
    except Exception as e:
        logger.error(f"Error in create_task: {str(e)}")
        raise

async def get_comments(task_id: int):
    async with aiohttp.ClientSession() as session:
        async with session.get(
            f"{FASTAPI_SERVICE_URL}/comments/task/{task_id}"
        ) as response:
            return await response.json()

async def add_comment(task_id: int, text: str):
    try:
        async with aiohttp.ClientSession() as session:
            headers = {
                "X-Bot-Access": "true",
                "Content-Type": "application/json"
            }
            data = {"task_id": task_id, "text": text}
            logger.info(f"Sending comment data: {data}")
            async with session.post(
                f"{FASTAPI_SERVICE_URL}/comments/",
                json=data,
                headers=headers
            ) as response:
                response_text = await response.text()
                logger.info(f"Comment creation response: {response_text}")
                
                if response.status != 201 and response.status != 200:
                    logger.error(f"Error creating comment. Status: {response.status}, Response: {response_text}")
                    raise ValueError(f"Failed to create comment: {response_text}")
                
                return await response.json()
    except Exception as e:
        logger.error(f"Error in add_comment: {str(e)}")
        raise

# –î–∏–∞–ª–æ–≥ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∑–∞–¥–∞—á–∞–º–∏
async def get_tasks_keyboard():
    try:
        tasks = await get_tasks(0)  # 0 –≤—Ä–µ–º–µ–Ω–Ω–æ, –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π user_id
        keyboard = []
        
        if not tasks:
            keyboard.append([
                types.InlineKeyboardButton(
                    text="‚ú® –°–æ–∑–¥–∞—Ç—å –ø–µ—Ä–≤—É—é –∑–∞–¥–∞—á—É",
                    callback_data="add_task"
                )
            ])
        else:
            for task in tasks:
                keyboard.append([
                    types.InlineKeyboardButton(
                        text=f"üìù {task['title']} ({task['created_at']})",
                        callback_data=f"task:{task['id']}"
                    )
                ])
            keyboard.append([
                types.InlineKeyboardButton(
                    text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É",
                    callback_data="add_task"
                )
            ])
        
        keyboard.append([
            types.InlineKeyboardButton(
                text="‚ùì –ü–æ–º–æ—â—å",
                callback_data="help"
            )
        ])
        
        keyboard.append([
            types.InlineKeyboardButton(
                text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é",
                callback_data="back_to_menu"
            )
        ])
        
        return types.InlineKeyboardMarkup(inline_keyboard=keyboard)
    except Exception as e:
        logger.error(f"Error getting tasks: {e}")
        keyboard = [
            [types.InlineKeyboardButton(
                text="üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞",
                callback_data="retry_tasks"
            )],
            [types.InlineKeyboardButton(
                text="‚ùì –ü–æ–º–æ—â—å",
                callback_data="help"
            )],
            [types.InlineKeyboardButton(
                text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é",
                callback_data="back_to_menu"
            )]
        ]
        return types.InlineKeyboardMarkup(inline_keyboard=keyboard)

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏", callback_data="back_to_tasks")],
        [types.InlineKeyboardButton(text="üì¶ –ê—Ä—Ö–∏–≤ –∑–∞–¥–∞—á", callback_data="show_archive")],
        [types.InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É", callback_data="add_task")],
        [types.InlineKeyboardButton(text="üìÅ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏", callback_data="categories")],
        [types.InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="help")]
    ])

    await message.answer(
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ ToDo –±–æ—Ç!\n\n"
        "ü§ñ –û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:\n"
        "üìù –°–æ–∑–¥–∞–Ω–∏–µ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏\n"
        "üì¶ –ê—Ä—Ö–∏–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á\n"
        "üè∑ –†–∞–±–æ—Ç–∞ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏\n"
        "üîç –ü–æ–∏—Å–∫ –ø–æ –∑–∞–¥–∞—á–∞–º\n"
        "üìÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ä–æ–∫–æ–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è\n"
        "üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –¥–µ–¥–ª–∞–π–Ω–∞—Ö\n"
        "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/tasks - —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á\n"
        "/archive - –∞—Ä—Ö–∏–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á\n"
        "/add - –¥–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É\n"
        "/categories - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏\n"
        "/search - –ø–æ–∏—Å–∫ –ø–æ –∑–∞–¥–∞—á–∞–º\n"
        "/stats - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        "/deadlines - –ø—Ä–∏–±–ª–∏–∂–∞—é—â–∏–µ—Å—è –¥–µ–¥–ª–∞–π–Ω—ã\n"
        "/help - –ø–æ–º–æ—â—å",
        reply_markup=keyboard
    )

@dp.message(Command("tasks"))
async def cmd_tasks(message: types.Message):
    try:
        keyboard = await get_tasks_keyboard()
        tasks = await get_tasks(0)
        
        if not tasks:
            text = "üìã –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á.\n–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä–≤—É—é –∑–∞–¥–∞—á—É!"
        else:
            text = "üìã –í–∞—à–∏ –∑–∞–¥–∞—á–∏:\n–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É, —á—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é"
        
        await message.answer(text, reply_markup=keyboard)
    except Exception as e:
        logger.error(f"Error in cmd_tasks: {e}")
        await message.answer(
            "üòî –ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞—á.\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞'",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(
                    text="üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞",
                    callback_data="retry_tasks"
                )]
            ])
        )

@dp.callback_query(lambda c: c.data == "retry_tasks")
async def retry_tasks(callback_query: types.CallbackQuery):
    await cmd_tasks(callback_query.message)
    await callback_query.answer()

@dp.callback_query(lambda c: c.data == "help")
async def show_help(callback_query: types.CallbackQuery):
    help_text = (
        "ü§ñ *–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:*\n\n"
        "*–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:*\n"
        "üìã */tasks* - –ø—Ä–æ—Å–º–æ—Ç—Ä –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏\n"
        "‚ûï */add* - —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏\n"
        "üìÅ */categories* - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏\n"
        "üîç */search* - –ø–æ–∏—Å–∫ –ø–æ –∑–∞–¥–∞—á–∞–º\n"
        "üìä */stats* - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è\n"
        "üîî */deadlines* - –ø—Ä–∏–±–ª–∏–∂–∞—é—â–∏–µ—Å—è –¥–µ–¥–ª–∞–π–Ω—ã\n\n"
        "*–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏:*\n"
        "‚úÖ –û—Ç–º–µ—Ç–∏—Ç—å –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é\n"
        "üóë –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É\n"
        "üìù –î–æ–±–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π\n"
        "üìÖ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è\n\n"
        "*–ö–∞—Ç–µ–≥–æ—Ä–∏–∏:*\n"
        "üìù –°–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é\n"
        "üóë –£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é\n"
        "üìã –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ø–∏—Å–æ–∫\n"
        "üîç –§–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –∑–∞–¥–∞—á–∏ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏\n\n"
        "‚ùì –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã:\n"
        "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞\n"
        "‚Ä¢ –ù–∞–∂–º–∏—Ç–µ '–û—Ç–º–µ–Ω–∞' –≤ –ª—é–±–æ–º –¥–∏–∞–ª–æ–≥–µ\n"
        "‚Ä¢ –û–±–Ω–æ–≤–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á —á–µ—Ä–µ–∑ /tasks"
    )
    
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìã –ú–æ–∏ –∑–∞–¥–∞—á–∏", callback_data="back_to_tasks")],
        [types.InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É", callback_data="add_task")],
        [types.InlineKeyboardButton(text="üìÅ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏", callback_data="categories")]
    ])
    
    await callback_query.message.edit_text(
        help_text,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )
    await callback_query.answer()

@dp.callback_query(lambda c: c.data.startswith("task:"))
async def process_task(callback_query: types.CallbackQuery):
    try:
        task_id = int(callback_query.data.split(":")[1])
        comments = await get_comments(task_id)
        
        text = "üí¨ *–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ –∑–∞–¥–∞—á–µ:*\n\n"
        if not comments:
            text += "–ü–æ–∫–∞ –Ω–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤. –ë—É–¥—å—Ç–µ –ø–µ—Ä–≤—ã–º!\n"
        else:
            for comment in comments:
                text += f"‚Ä¢ _{comment['text']}_\n"
        
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [
                types.InlineKeyboardButton(text="‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ", callback_data=f"complete_task:{task_id}"),
                types.InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_task:{task_id}")
            ],
            [types.InlineKeyboardButton(text="‚úèÔ∏è –î–æ–±–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π", callback_data=f"add_comment:{task_id}")],
            [types.InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∑–∞–¥–∞—á–∞–º", callback_data="back_to_tasks")]
        ])
        
        await callback_query.message.edit_text(
            text,
            reply_markup=keyboard,
            parse_mode="Markdown"
        )
    except Exception as e:
        logger.error(f"Error processing task: {e}")
        await callback_query.message.edit_text(
            "üòî –ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∑–∞–¥–∞—á–∞–º", callback_data="back_to_tasks")]
            ])
        )

@dp.callback_query(lambda c: c.data.startswith("complete_task:"))
async def complete_task(callback_query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–º–µ—Ç–∫–∏ –∑–∞–¥–∞—á–∏ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π."""
    try:
        task_id = int(callback_query.data.split(":")[1])
        updated_task = await update_task(task_id, {"completed": True})
        
        if updated_task:
            await callback_query.answer("‚úÖ –ó–∞–¥–∞—á–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ –∞—Ä—Ö–∏–≤!")
            keyboard = await get_tasks_keyboard()
            await callback_query.message.edit_text(
                "–í–∞—à–∏ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏:",
                reply_markup=keyboard
            )
        else:
            await callback_query.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–¥–∞—á—É")
    except Exception as e:
        logger.error(f"Error completing task: {e}")
        await callback_query.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

@dp.callback_query(lambda c: c.data.startswith("delete_task:"))
async def confirm_delete_task(callback_query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∏."""
    task_id = int(callback_query.data.split(":")[1])
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [
            types.InlineKeyboardButton(text="‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_delete:{task_id}"),
            types.InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="back_to_tasks")
        ]
    ])
    await callback_query.message.edit_text(
        "‚ùóÔ∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–∞–¥–∞—á—É?",
        reply_markup=keyboard
    )

@dp.callback_query(lambda c: c.data.startswith("confirm_delete:"))
async def delete_task_handler(callback_query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∏."""
    try:
        task_id = int(callback_query.data.split(":")[1])
        if await delete_task(task_id):
            await callback_query.answer("‚úÖ –ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!")
            keyboard = await get_tasks_keyboard()
            await callback_query.message.edit_text(
                "–í–∞—à–∏ –∑–∞–¥–∞—á–∏:",
                reply_markup=keyboard
            )
        else:
            await callback_query.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É")
    except Exception as e:
        logger.error(f"Error deleting task: {e}")
        await callback_query.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

@dp.callback_query(lambda c: c.data == "add_task")
async def process_add_task(callback_query: types.CallbackQuery, state: FSMContext):
    await state.set_state(TaskStates.adding_task)
    await callback_query.message.edit_text(
        "üìù *–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏*\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏.\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: '_–ö—É–ø–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã_' –∏–ª–∏ '_–ü–æ–∑–≤–æ–Ω–∏—Ç—å –º–∞–º–µ_'",
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(
                text="‚ùå –û—Ç–º–µ–Ω–∞",
                callback_data="cancel"
            )]
        ]),
        parse_mode="Markdown"
    )

@dp.message(TaskStates.adding_task)
async def process_task_title(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è –∑–∞–¥–∞—á–∏."""
    await state.update_data(title=message.text)
    await state.set_state(TaskStates.adding_task_description)
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –ø—Ä–æ–ø—É—Å–∫–∞ –æ–ø–∏—Å–∞–Ω–∏—è
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_description")]
    ])
    
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å':",
        reply_markup=keyboard
    )

@dp.callback_query(lambda c: c.data == "skip_description")
async def skip_description(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ–ø—É—Å–∫–∞ –æ–ø–∏—Å–∞–Ω–∏—è –∑–∞–¥–∞—á–∏."""
    await callback_query.answer()
    await state.update_data(description="")
    
    # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–°–µ–≥–æ–¥–Ω—è", callback_data="due_today")],
        [types.InlineKeyboardButton(text="–ó–∞–≤—Ç—Ä–∞", callback_data="due_tomorrow")],
        [types.InlineKeyboardButton(text="–ß–µ—Ä–µ–∑ –Ω–µ–¥–µ–ª—é", callback_data="due_week")],
        [types.InlineKeyboardButton(text="‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_due_date")]
    ])
    
    await state.set_state(TaskStates.setting_due_date)
    await callback_query.message.answer(
        "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏:",
        reply_markup=keyboard
    )

@dp.callback_query(lambda c: c.data.startswith("due_"))
async def process_due_date(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Å—Ä–æ–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è."""
    await callback_query.answer()
    
    today = datetime.now()
    if callback_query.data == "due_today":
        due_date = today
    elif callback_query.data == "due_tomorrow":
        due_date = today + timezone.timedelta(days=1)
    elif callback_query.data == "due_week":
        due_date = today + timezone.timedelta(days=7)
    else:  # skip_due_date
        due_date = None
    
    await state.update_data(due_date=due_date.isoformat() if due_date else None)
    
    # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –≤—ã–±–æ—Ä—É –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    categories = await get_categories()
    if categories:
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(
                text=cat['name'],
                callback_data=f"cat_{cat['id']}"
            )] for cat in categories
        ] + [[types.InlineKeyboardButton(
            text="‚û°Ô∏è –ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
            callback_data="skip_category"
        )]])
        
        await state.set_state(TaskStates.selecting_category)
        await callback_query.message.edit_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –∑–∞–¥–∞—á–∏:",
            reply_markup=keyboard
        )
    else:
        # –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –±–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        data = await state.get_data()
        task = await create_task(
            callback_query.from_user.id,
            data['title'],
            data['description'],
            [],
            data.get('due_date')
        )
        if task:
            text = f"‚úÖ –ó–∞–¥–∞—á–∞ '{task['title']}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!"
            if task.get('due_date'):
                text += f"\nüìÖ –°—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {task['due_date']}"
            await callback_query.message.edit_text(text)
        else:
            await callback_query.message.edit_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
        await state.clear()

@dp.message(TaskStates.adding_task_description)
async def process_task_description(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –æ–ø–∏—Å–∞–Ω–∏—è –∑–∞–¥–∞—á–∏."""
    await state.update_data(description=message.text)
    
    # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–°–µ–≥–æ–¥–Ω—è", callback_data="due_today")],
        [types.InlineKeyboardButton(text="–ó–∞–≤—Ç—Ä–∞", callback_data="due_tomorrow")],
        [types.InlineKeyboardButton(text="–ß–µ—Ä–µ–∑ –Ω–µ–¥–µ–ª—é", callback_data="due_week")],
        [types.InlineKeyboardButton(text="‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_due_date")]
    ])
    
    await state.set_state(TaskStates.setting_due_date)
    await message.answer(
        "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏:",
        reply_markup=keyboard
    )

@dp.callback_query(lambda c: c.data.startswith("cat_"))
async def process_category_selection(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏."""
    await callback_query.answer()
    category_id = int(callback_query.data.split("_")[1])
    data = await state.get_data()
    
    task = await create_task(
        callback_query.from_user.id,
        data['title'],
        data['description'],
        [category_id],
        data.get('due_date')
    )
    
    if task:
        await callback_query.message.answer(
            f"‚úÖ –ó–∞–¥–∞—á–∞ '{task['title']}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é!"
        )
    else:
        await callback_query.message.answer(
            "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )
    await state.clear()

@dp.callback_query(lambda c: c.data == "skip_category")
async def skip_category(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ–ø—É—Å–∫–∞ –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    await callback_query.answer()
    data = await state.get_data()
    
    task = await create_task(
        callback_query.from_user.id,
        data['title'],
        data['description'],
        [],
        data.get('due_date')
    )
    
    if task:
        await callback_query.message.answer(
            f"‚úÖ –ó–∞–¥–∞—á–∞ '{task['title']}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!"
        )
    else:
        await callback_query.message.answer(
            "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )
    await state.clear()

@dp.callback_query(lambda c: c.data == "back_to_tasks")
async def back_to_tasks(callback_query: types.CallbackQuery):
    keyboard = await get_tasks_keyboard()
    await callback_query.message.edit_text("–í–∞—à–∏ –∑–∞–¥–∞—á–∏:", reply_markup=keyboard)

@dp.callback_query(lambda c: c.data == "cancel")
async def cancel_operation(callback_query: types.CallbackQuery, state: FSMContext):
    await state.clear()
    keyboard = await get_tasks_keyboard()
    await callback_query.message.edit_text("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞. –í–∞—à–∏ –∑–∞–¥–∞—á–∏:", reply_markup=keyboard)

@dp.message(Command("add"))
async def cmd_add(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /add."""
    await state.set_state(TaskStates.adding_task)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")

@dp.message(Command("categories"))
async def cmd_categories(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /categories."""
    await state.set_state(CategoryStates.selecting_action)
    await message.answer(
        "üìÅ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=category_keyboard
    )

@dp.callback_query(lambda c: c.data == "create_category")
async def process_create_category(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    await callback_query.answer()
    await state.set_state(CategoryStates.adding_category)
    await callback_query.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:")

@dp.message(CategoryStates.adding_category)
async def add_category(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –Ω–∞–∑–≤–∞–Ω–∏—è –Ω–æ–≤–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    category = await create_category(message.text)
    if category:
        await message.answer(f"‚úÖ –ö–∞—Ç–µ–≥–æ—Ä–∏—è '{category['name']}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!")
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    await state.clear()

@dp.callback_query(lambda c: c.data == "list_categories")
async def process_list_categories(callback_query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ø–∏—Å–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π."""
    await callback_query.answer()
    categories = await get_categories()
    if categories:
        text = "üìÅ –°–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π:\n\n"
        for cat in categories:
            text += f"‚Ä¢ {cat['name']}\n"
        await callback_query.message.answer(text)
    else:
        await callback_query.message.answer("–°–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –ø—É—Å—Ç.")

@dp.callback_query(lambda c: c.data == "delete_category")
async def process_delete_category(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ —É–¥–∞–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    await callback_query.answer()
    categories = await get_categories()
    if not categories:
        await callback_query.message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return

    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(
            text=cat['name'],
            callback_data=f"del_cat_{cat['id']}"
        )] for cat in categories
    ])
    await state.set_state(CategoryStates.deleting_category)
    await callback_query.message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        reply_markup=keyboard
    )

@dp.callback_query(lambda c: c.data.startswith("del_cat_"))
async def delete_category_confirm(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è."""
    await callback_query.answer()
    category_id = int(callback_query.data.split("_")[2])
    if await delete_category(category_id):
        await callback_query.message.answer("‚úÖ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!")
    else:
        await callback_query.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
    await state.clear()

@dp.callback_query(lambda c: c.data == "tasks_by_category")
async def process_tasks_by_category(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–¥–∞—á –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    await callback_query.answer()
    categories = await get_categories()
    if not categories:
        await callback_query.message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π.")
        return

    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(
            text=cat['name'],
            callback_data=f"view_cat_{cat['id']}"
        )] for cat in categories
    ])
    await state.set_state(CategoryStates.viewing_tasks)
    await callback_query.message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–¥–∞—á:",
        reply_markup=keyboard
    )

@dp.callback_query(lambda c: c.data.startswith("view_cat_"))
async def view_category_tasks(callback_query: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–¥–∞—á."""
    await callback_query.answer()
    category_id = int(callback_query.data.split("_")[2])
    tasks = await get_tasks_by_category(category_id)
    
    if tasks:
        text = "üìã –ó–∞–¥–∞—á–∏ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:\n\n"
        for task in tasks:
            status = "‚úÖ" if task['completed'] else "‚è≥"
            text += f"{status} {task['title']}\n"
            if task['description']:
                text += f"üìù {task['description']}\n"
            text += "\n"
        await callback_query.message.answer(text)
    else:
        await callback_query.message.answer("–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç –∑–∞–¥–∞—á.")
    await state.clear()

@dp.message(Command("search"))
async def cmd_search(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search."""
    await state.set_state(TaskStates.searching)
    await message.answer(
        "üîç –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–¥–∞—á–∞–º:\n"
        "(–ø–æ–∏—Å–∫ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∏ –æ–ø–∏—Å–∞–Ω–∏—é –∑–∞–¥–∞—á)",
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
        ])
    )

@dp.message(TaskStates.searching)
async def process_search(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞."""
    tasks = await search_tasks(message.text)
    if tasks:
        text = "üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞:\n\n"
        for task in tasks:
            status = "‚úÖ" if task['completed'] else "‚è≥"
            text += f"{status} {task['title']}\n"
            if task['description']:
                text += f"üìù {task['description']}\n"
            if task['due_date']:
                text += f"üìÖ –°—Ä–æ–∫: {task['due_date']}\n"
            text += "\n"
    else:
        text = "üòî –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
    
    await message.answer(text)
    await state.clear()

@dp.message(Command("stats"))
async def cmd_stats(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /stats."""
    stats = await get_statistics()
    if stats:
        text = (
            "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∑–∞–¥–∞—á–∞–º:\n\n"
            f"–í—Å–µ–≥–æ –∑–∞–¥–∞—á: {stats['total_tasks']}\n"
            f"–í—ã–ø–æ–ª–Ω–µ–Ω–æ: {stats['completed_tasks']}\n"
            f"–ü—Ä–æ—Ü–µ–Ω—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {stats['completion_rate']}\n"
            f"–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ: {stats['overdue_tasks']}"
        )
    else:
        text = "üòî –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"
    
    await message.answer(text)

@dp.message(Command("deadlines"))
async def cmd_deadlines(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /deadlines."""
    tasks = await get_upcoming_deadlines()
    if tasks:
        text = "üîî –ü—Ä–∏–±–ª–∏–∂–∞—é—â–∏–µ—Å—è –¥–µ–¥–ª–∞–π–Ω—ã:\n\n"
        for task in tasks:
            text += f"üìÖ {task['due_date']}\n"
            text += f"üìù {task['title']}\n"
            if task['description']:
                text += f"‚ÑπÔ∏è {task['description']}\n"
            text += "\n"
    else:
        text = "üéâ –ù–µ—Ç –ø—Ä–∏–±–ª–∏–∂–∞—é—â–∏—Ö—Å—è –¥–µ–¥–ª–∞–π–Ω–æ–≤"
    
    await message.answer(text)

@dp.message(Command("archive"))
async def cmd_archive(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /archive."""
    tasks = await get_archived_tasks()
    if tasks:
        text = "üì¶ *–ê—Ä—Ö–∏–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á:*\n\n"
        for task in tasks:
            text += f"‚úÖ *{task['title']}*\n"
            if task['description']:
                text += f"üìù {task['description']}\n"
            if task['due_date']:
                text += f"üìÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {task['due_date']}\n"
            text += "\n"
    else:
        text = "üì¶ –ê—Ä—Ö–∏–≤ –ø—É—Å—Ç"
    
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏", callback_data="back_to_tasks")]
    ])
    
    await message.answer(text, reply_markup=keyboard, parse_mode="Markdown")

@dp.callback_query(lambda c: c.data == "show_archive")
async def show_archive(callback_query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∞—Ä—Ö–∏–≤–∞."""
    tasks = await get_archived_tasks()
    if tasks:
        text = "üì¶ *–ê—Ä—Ö–∏–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á:*\n\n"
        for task in tasks:
            text += f"‚úÖ *{task['title']}*\n"
            if task['description']:
                text += f"üìù {task['description']}\n"
            if task['due_date']:
                text += f"üìÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {task['due_date']}\n"
            text += "\n"
    else:
        text = "üì¶ –ê—Ä—Ö–∏–≤ –ø—É—Å—Ç"
    
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏", callback_data="back_to_tasks")]
    ])
    
    await callback_query.message.edit_text(
        text,
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@dp.callback_query(lambda c: c.data == "back_to_menu")
async def back_to_menu(callback_query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."""
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏", callback_data="back_to_tasks")],
        [types.InlineKeyboardButton(text="üì¶ –ê—Ä—Ö–∏–≤ –∑–∞–¥–∞—á", callback_data="show_archive")],
        [types.InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É", callback_data="add_task")],
        [types.InlineKeyboardButton(text="üìÅ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏", callback_data="categories")],
        [types.InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="help")]
    ])

    await callback_query.message.edit_text(
        "ü§ñ –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=keyboard
    )

async def search_tasks(query: str):
    """–ü–æ–∏—Å–∫ –∑–∞–¥–∞—á –ø–æ –∑–∞–ø—Ä–æ—Å—É."""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {"X-Bot-Access": "true"}
            params = {"search": query}
            async with session.get(
                f"{DJANGO_SERVICE_URL}/api/tasks/search/",
                headers=headers,
                params=params
            ) as response:
                if response.status == 200:
                    return await response.json()
                logger.error(f"Error searching tasks: {response.status}")
                return []
    except Exception as e:
        logger.error(f"Error in search_tasks: {str(e)}")
        return []

async def get_statistics():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –∑–∞–¥–∞—á–∞–º."""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {"X-Bot-Access": "true"}
            params = {"show_completed": "true"}  # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
            async with session.get(
                f"{DJANGO_SERVICE_URL}/api/tasks/",
                headers=headers,
                params=params
            ) as response:
                if response.status == 200:
                    tasks = await response.json()
                    total_tasks = len(tasks)
                    completed_tasks = len([task for task in tasks if task['completed']])
                    completion_rate = f"{(completed_tasks / total_tasks * 100):.1f}%" if total_tasks > 0 else "0%"
                    overdue_tasks = len([
                        task for task in tasks 
                        if not task['completed'] 
                        and task.get('due_date') 
                        and datetime.fromisoformat(task['due_date'].replace('Z', '+00:00')) < datetime.now(timezone.utc)
                    ])
                    
                    return {
                        'total_tasks': total_tasks,
                        'completed_tasks': completed_tasks,
                        'completion_rate': completion_rate,
                        'overdue_tasks': overdue_tasks
                    }
                logger.error(f"Error getting tasks for statistics: {response.status}")
                return None
    except Exception as e:
        logger.error(f"Error in get_statistics: {str(e)}")
        return None

async def get_upcoming_deadlines():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø—Ä–∏–±–ª–∏–∂–∞—é—â–∏—Ö—Å—è –¥–µ–¥–ª–∞–π–Ω–æ–≤."""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {"X-Bot-Access": "true"}
            async with session.get(
                f"{DJANGO_SERVICE_URL}/api/tasks/upcoming_deadlines/",
                headers=headers
            ) as response:
                if response.status == 200:
                    return await response.json()
                logger.error(f"Error getting deadlines: {response.status}")
                return []
    except Exception as e:
        logger.error(f"Error in get_upcoming_deadlines: {str(e)}")
        return []

async def update_task(task_id: int, data: dict):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏."""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {
                "X-Bot-Access": "true",
                "Content-Type": "application/json"
            }
            async with session.patch(
                f"{DJANGO_SERVICE_URL}/api/tasks/{task_id}/",
                json=data,
                headers=headers
            ) as response:
                if response.status == 200:
                    return await response.json()
                logger.error(f"Error updating task: {response.status}")
                return None
    except Exception as e:
        logger.error(f"Error in update_task: {str(e)}")
        return None

async def delete_task(task_id: int):
    """–£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏."""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {"X-Bot-Access": "true"}
            async with session.delete(
                f"{DJANGO_SERVICE_URL}/api/tasks/{task_id}/",
                headers=headers
            ) as response:
                return response.status == 204
    except Exception as e:
        logger.error(f"Error in delete_task: {str(e)}")
        return False

async def get_archived_tasks():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á."""
    try:
        async with aiohttp.ClientSession() as session:
            headers = {"X-Bot-Access": "true"}
            params = {"show_completed": "true"}
            async with session.get(
                f"{DJANGO_SERVICE_URL}/api/tasks/",
                headers=headers,
                params=params
            ) as response:
                if response.status == 200:
                    tasks = await response.json()
                    # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏
                    return [task for task in tasks if task['completed']]
                logger.error(f"Error getting archived tasks: {response.status}")
                return []
    except Exception as e:
        logger.error(f"Error in get_archived_tasks: {str(e)}")
        return []

async def main():
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –≤ –º–µ–Ω—é
    try:
        await bot.set_my_commands(main_menu_commands)
        logger.info("Bot commands set successfully")
    except Exception as e:
        logger.error(f"Error setting bot commands: {e}")

    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main()) 